<?php

/**
 * @file
 * Hooks and other always-needed functions for the islandora_webform_ingest
 * module.
 */

/**
 * Implements hook_menu().
 */
function islandora_webform_ingest_menu() {
  return array(
    'islandora_webform_submission/%ctools_js/ingest/%' => array(
      'title' => 'Ingest Webform Submission',
      'page callback' => 'iwi_preview_ingest_submission_form_callback',
      'page arguments' => array(1, 3),
      'access arguments' => array('ingest islandora webform submissions'),
    ),
    'islandora_webform_submission/ingest/%' => array(
      'title' => 'Ingest Webform Submission',
      'page callback' => 'iwi_preview_ingest_submission_form_callback',
      'page arguments' => array(FALSE, 2),
      'access arguments' => array(2),
      'access callback' => 'iwi_ingest_access',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function islandora_webform_ingest_permission() {
  return array(
    'ingest islandora webform submissions' => array(
      'title' => t('Ingest Islandora Webform Submissions'),
      'description' => t('Add content submitted by islandora webforms to metadata on objects in the repository.'),
    ),
    // TODO in the future: bulk ingest
//    'bulk ingest islandora webform submissions' => array(
//      'title' => t('Bulk Ingest Islandora Webform Submissions'),
//      'description' => t('Add content submitted by islandora webforms to metadata on objects in the repository.'),
//    ),
  );
}

/**
 * Access callback for islandora webform ingest.
 *
 * @param mixed $sid
 *   Submission id - if provided, checks to see if ingestion is enabled for
 *   that submission
 *
 * @return bool
 *   TRUE = access permitted; FALSE = access denied
 */
function iwi_ingest_access($sid = FALSE) {
  if ($sid) {
    $query = db_select('webform_submissions', 's');
    $query->join('islandora_webform_ingest_webforms', 'w', "w.nid = s.nid");
    $query->join('islandora_webform_ingest_map', 'm', "m.nid = w.nid");
    $query->fields('w', array('ingest_enabled'));
    $query->condition('s.sid', $sid);
    $enabled = $query->execute()->fetchField();
  }
  else {
    $enabled = TRUE;
  }
  return $enabled && user_access('ingest islandora webform submissions');
}

/**
 * Implements hook_webform_submission_load().
 *
 * Add IslandoraFedoraObject to islandora webform submissions on load
 */
function islandora_webform_ingest_webform_submission_load(&$submissions) {
  foreach ($submissions as &$submission) {
    $submission->islandora_object = FALSE;
    $islandora_component_id = db_select('webform_component', 'wc')
      ->fields('wc', array('cid'))
      ->condition('nid', $submission->nid)
      ->condition('form_key', 'islandora_object_pid')
      ->execute()->fetchField();
    if ($islandora_component_id && !empty($submission->data[$islandora_component_id][0])) {
      $submission->islandora_object = islandora_object_load($submission->data[$islandora_component_id][0]);
    }
  }
}


/**
 * Implements hook_form_alter().
 *
 * Adds datastream mapping options to webform component edit form.
 */
function islandora_webform_ingest_form_alter(&$form, &$form_state, $form_id) {

  if ($form_id == 'webform_component_edit_form' && !empty($form['cid']['#value'])) {


    form_load_include($form_state, 'inc', 'islandora_webform_ingest', 'includes/utilities');
    form_load_include($form_state, 'inc', 'webform', 'components/select');
    form_load_include($form_state, 'inc', 'webform', 'components/file');

    $webform_ingest_config = db_select('islandora_webform_ingest_webforms', 'c')
      ->fields('c')
      ->condition('c.nid', $form['#node']->nid)
      ->execute()
      ->fetch();

    if ($webform_ingest_config && $webform_ingest_config->ingest_enabled) {
      if (!empty($form['type']['#value']) && in_array($form['type']['#value'], islandora_webform_ingest_get_component_types())) {

        // If a content model is defined in the ingest configuration, use that.
        // Otherwise, use the content model defined in the webform.
        $cmodel = $webform_ingest_config->cmodel ? $webform_ingest_config->cmodel : iwi_webform_content_model($form['#node']->nid);

        if ($cmodel) {

          $cmodel = islandora_object_load($cmodel);

          // Get datastream mimetypes.
          $dsmimetypes = iwi_datastream_mime_from_component($form['#node']->webform['components'][$form['cid']['#value']]);

          // Start building the form.
          $form['ingest'] = array(
            '#type' => 'fieldset',
            '#title' => 'Islandora Ingest Mapping',
            '#collapsible' => TRUE,
            '#collapsed' => TRUE,
            '#weight' => 5,
          );

          // Load most the form elements.
          $mapping_fields = islandora_webform_ingest_form_ingest_mapping_fields($form, $form_state, $cmodel, $dsmimetypes);
          if (!empty($mapping_fields)) {
            $form['ingest'] = array_merge($form['ingest'], $mapping_fields);

            $description = array();
            $description[] = t('Choose the datastream and field that this component should be ingested to. Note that this only sets the default values, and can be overridden at the time a submission is ingested.');
            if (!$webform_ingest_config->cmodel) {
              $description[] = t('You are ingesting to datastreams on the existing object. <strong>Be very careful - this can permanently overwrite existing data!</strong>');
            }
            else {
              $description[] = t('You are ingesting to a new %cmodel object', array('%cmodel' => $cmodel->label));
              $description[] = t('It will be related by %relation to the existing object', array('%relation' => $webform_ingest_config->relation));
            }
            $form['ingest']['long_description'] = array(
              '#weight' => 2,
              '#type' => 'container',
              'content' => array(
                '#markup' => implode('<br />', $description)
              ),
              '#states' => array(
                // Hide if mode is not selected.
                'invisible' => array(
                  ':input[name="ingest[mode]"]' => array('value' => ''),
                ),
              ),
            );
            $form['#submit'][] = 'iwi_webform_component_edit_form_submit';
            $form['#validate'][] = 'iwi_webform_component_edit_form_validate';
          }
          else {
            $form['ingest']['#description'] = t('@cmodel provides no datastreams that can be populated from this webform field type.', array('@cmodel' => $cmodel->label));
          }
        }
      }
    }
  }
  else {
    if ($form_id == 'islandora_webform_configure_form') {

      $default_values = db_select('islandora_webform_ingest_webforms', 'm')
        ->fields('m')
        ->condition('m.nid', $form['nid']['#value'])
        ->execute()->fetchAssoc();

      $cmodel_options = array('' => 'Ingest to current object');
      form_load_include($form_state, 'inc', 'islandora', 'includes/utilities');
      $cmodels = islandora_get_content_models();
      asort($cmodels);
      foreach ($cmodels as $cmodel) {
        $cmodel_options[$cmodel['pid']] = t('Create new @cmodel', array('@cmodel' => $cmodel['label']));
      }

      $form['islandora_ingest'] = array(
        '#type' => 'fieldset',
        '#title' => 'Islandora Ingest',
        '#description' => t('Configure ingest settings for this webform.'),
        '#collapsible' => FALSE,
        '#tree' => TRUE,
        'ingest_enabled' => array(
          '#type' => 'checkbox',
          '#title' => t('Enable'),
          '#description' => t('Enable ingest for this webform'),
          '#default_value' => $default_values['ingest_enabled'] ? $default_values['ingest_enabled'] : 0,
        ),
        'cmodel' => array(
          '#type' => 'select',
          '#title' => 'Ingest destination',
          '#description' => t('Select whether to ingest to the current object, or to a new object/content-model. <br />
          <strong>If you change a previously saved ingestion destination, all component ingestion mappings that you had previously defined for this webform will be deleted and will need to be recreated.</strong>
           <br />
          If you select to ingest to the current object, then a content model filter must be selected above.
          This is needed in order to be able to map submitted data to datastreams in your content model.'),
          '#default_value' => $default_values['cmodel'] ? $default_values['cmodel'] : '',
          '#options' => $cmodel_options,
        ),
        'relation' => array(
          '#type' => 'textfield',
          '#title' => 'Relationship to current object',
          '#description' => t('Provide a name for the relationship of the new object to the original object, e.g. "isTranscriptionOf". This must be a string with only upper and lower case letters and no spaces.'),
          '#default_value' => $default_values['relation'] ? $default_values['relation'] : 'isChildOf',
          '#states' => array(
            // Hide if cmodel is not chosen.
            'invisible' => array(
              ':input[name="islandora_ingest[cmodel]"]' => array('value' => ''),
            ),
          ),
        ),
        'namespace' => array(
          '#type' => 'textfield',
          '#title' => 'Namespace of new object',
          '#description' => t('Provide a namespace for the newly created object.'),
          '#default_value' => $default_values['namespace'] ? $default_values['namespace'] : 'islandora',
          '#states' => array(
            // Hide if cmodel is not chosen.
            'invisible' => array(
              ':input[name="islandora_ingest[cmodel]"]' => array('value' => ''),
            ),
          ),
        ),
      );
      $form['#submit'][] = 'iwi_islandora_webform_configure_form_submit';
      $form['#validate'][] = 'iwi_islandora_webform_configure_form_validate';

      // Adjust weights.
      $form['islandora']['#weight'] = 0;
      $form['islandora_ingest']['#weight'] = 1;
      $form['actions']['#weight'] = 2;

    }
  }
}

/**
 * Delete a component ingest mapping.
 *
 * @param object $component
 *   A webform component
 */
function islandora_webform_ingest_webform_component_delete($component) {
  db_delete('islandora_webform_ingest_map')
    ->condition('nid', $component['nid'])
    ->condition('cid', $component['cid'])
    ->execute();
}

/**
 * Form submit hook for islandora_ingest-enabled webform_component_edit_form.
 *
 * @param array $form
 *   The webform_component_edit_form form array
 * @param array $form_state
 *   The webform_component_edit_form form_state array
 */
function iwi_webform_component_edit_form_submit($form, &$form_state) {
  form_load_include($form_state, 'inc', 'islandora_webform_ingest', 'includes/utilities');
  iwi_save_component_mapping($form, $form_state);
}

/**
 * Form validate hook for islandora_ingest-enabled webform_component_edit_form.
 *
 * @param array $form
 *   The webform_component_edit_form form array
 * @param array $form_state
 *   The webform_component_edit_form form_state array
 */
function iwi_webform_component_edit_form_validate($form, &$form_state) {

  if ($form['type']['#value'] == 'file' && !empty($form_state['values']['ingest']['datastream'])) {
    if (preg_match('/\((.*)\)/U', $form_state['values']['ingest']['datastream'], $matches)) {
      $ds_mime = $matches[1];
      $types = $form_state['values']['extra']['filtering']['types'];
      if (count($types) == 0) {
        form_set_error('validation', t('You must specify one allowed file extension in the validation section when mapping a file component to a binary datastream.'));
      }
      if (count($types) > 1) {
        form_set_error('validation', t('You must specify only one allowed file extension in the validation section when mapping a file component to a binary datastream; @count were selected.', array('@count' => count($types))));
      }
      elseif (count($types) == 1) {
        form_load_include($form_state, 'inc', 'islandora_webform_ingest', 'includes/utilities');
        $filter_extension = reset($types);
        $filter_mime = iwi_get_mimetypes_from_extensions($filter_extension);
        if ($ds_mime != $filter_mime) {
          form_set_error('validation', t('The allowed file extension does not match the mimetype of the destination datastream.'));
        }
      }
    }
  }

  if (!empty($form_state['values']['ingest']['mode']) && isset($form['ingest']['fields_wrapper']['fields']['#required']) && $form['ingest']['fields_wrapper']['fields']['#required'] && empty($form_state['values']['ingest']['fields_wrapper']['fields'])) {

    form_set_error('ingest][fields_wrapper][fields', t('A field name is required.'));

  }

}

/**
 * Submit handler for webform ingest configuration sub-form.
 *
 * @param array $form
 *   the form
 * @param array $form_state
 *   the form state, passed by reference
 */
function iwi_islandora_webform_configure_form_submit($form, &$form_state) {
  form_load_include($form_state, 'inc', 'islandora_webform_ingest', 'includes/utilities');
  iwi_save_webform_configuration($form, $form_state);
}

/**
 * Form validate hook for  webform ingest configuration sub-form.
 *
 * @param array $form
 *   The form
 * @param array $form_state
 *   The form_state array
 */
function iwi_islandora_webform_configure_form_validate($form, &$form_state) {

  if ($form_state['values']['islandora_ingest']['ingest_enabled'] && empty($form_state['values']['islandora']['cmodel_filter']) && empty($form_state['values']['islandora_ingest']['cmodel'])) {

    form_set_error('islandora][cmodel_filter', t('If ingesting to current object, a content model filter must be chosen.'));

  }

  if ($form_state['values']['islandora_ingest']['ingest_enabled']
    && $form_state['values']['islandora_ingest']['cmodel']
    && !empty($form_state['values']['islandora_ingest']['relation'])
    && preg_match("/[^a-zA-Z]/", $form_state['values']['islandora_ingest']['relation'])
  ) {

    form_set_error('islandora_ingest][relation', t('Invalid string for relation. Relation must consist of upper and lower case letters without any spaces.'));

  }

  if ($form_state['values']['islandora_ingest']['ingest_enabled']
    && $form_state['values']['islandora_ingest']['cmodel']
    && !empty($form_state['values']['islandora_ingest']['namespace'])
    && preg_match("/[^a-z]/", $form_state['values']['islandora_ingest']['namespace'])
  ) {

    form_set_error('islandora_ingest][namespace', t('Invalid string for namespace. Namespace must consist of lower case letters only.'));

  }
}


/**
 * Build the component mapping destination options.
 *
 * @param array $form
 *   The component configuration form
 * @param array $form_state
 *   The component configuration form_state
 * @param IslandoraFedoraObject $cmodel
 *   The islandora fedora content model object
 * @param array $mimetypes
 *   A list of mimetypes if filtering by mimetype, otherwise an empty array
 *
 * @return array
 *   A renderable form array
 */
function islandora_webform_ingest_form_ingest_mapping_fields($form, $form_state, IslandoraFedoraObject $cmodel, $mimetypes = array()) {

  form_load_include($form_state, 'inc', 'islandora_webform_ingest', 'includes/utilities');

  // Get a list of the theoretically eligible destination datastreams.
  $datastreams = iwi_ingestable_datastreams($cmodel, $mimetypes);

  if (empty($datastreams)) {
    return FALSE;
  }
  // The datastreams options list that we are building.
  $dsoptions = array();

  // Build the datastream options by filtering the eligible datastreams.
  foreach ($datastreams as $datastream => $dsdata) {
    $dsoptions[$datastream] = $datastream;
  }

  $saved_values = iwi_get_saved_component_mapping($form['#node']->nid, $form['cid']['#value']);

  // Set defaults from form state if present, from saved otherwise,
  // and if neither, set as NULL.
  $mode_value = isset($form_state['values']['ingest']['mode']) ? $form_state['values']['ingest']['mode'] : (isset($saved_values['mode']) ? $saved_values['mode'] : NULL);
  $datastream_value = isset($form_state['values']['ingest']['datastream']) ? $form_state['values']['ingest']['datastream'] : (isset($saved_values['datastream']) ? $saved_values['datastream'] : NULL);
  $field_value = isset($form_state['values']['ingest']['field_wrapper']['fields']) ? $form_state['values']['ingest']['field_wrapper']['fields'] : (isset($saved_values['field']) ? $saved_values['field'] : NULL);

  $elements = array(
    'mode' => array(
      '#title' => 'Ingest?',
      '#description' => t('Do you want to ingest this component? If so, do you want to replace existing content, or append to it if possible?'),
      '#type' => 'select',
      '#weight' => 1,
      '#options' => array(
        '' => 'Do not ingest',
        'replace' => 'Replace',
        'append' => 'Append',
      ),
      '#default_value' => $mode_value,
    ),
    'datastream' => array(
      '#title' => 'DataStream',
      '#type' => 'select',
      '#options' => array_merge(array('' => '- Select datastream -'), $dsoptions),
      '#default_value' => $datastream_value,
      '#weight' => 3,
      '#ajax' => array(
        'event' => 'change',
        'callback' => 'iwi_ds_field_options_ajax',
        'wrapper' => 'ds_field_options',
      ),
      '#states' => array(
        // Hide if mode is not selected.
        'invisible' => array(
          ':input[name="ingest[mode]"]' => array('value' => ''),
        ),
      ),
    ),
    'fields_wrapper' => array(
      '#prefix' => '<div id="ds_field_options">',
      '#suffix' => '</div>',
      '#weight' => 4,
    ),
  );


  if ($datastream_value && !empty($datastreams[$datastream_value]['form_name'])) {
    // Now work on the fields dropdown list.
    $ds_field_options = array('- Select field -');
    $ds_field_options = array_merge($ds_field_options, iwi_ds_field_options($datastreams[$datastream_value], $mimetypes));
    $ds_field_default = empty($form_state['values']['ingest']['fields_wrapper']['fields']) ? $field_value : $form_state['values']['ingest']['fields_wrapper']['fields'];

    $elements['fields_wrapper'] = array(
      '#prefix' => '<div id="ds_field_options">',
      '#suffix' => '</div>',
      '#weight' => 4,
      'fields' => array(
        '#title' => 'Field',
        '#type' => 'select',
        '#options' => $ds_field_options,
        '#default_value' => $ds_field_default,
        '#required' => TRUE,
        '#states' => array(
          // Hide if mode is not selected.
          'invisible' => array(
            ':input[name="ingest[mode]"]' => array('value' => ''),
          ),
        ),
      ),

    );

  }
  return $elements;
}

/**
 * Get a list of webform component types that we can use as sources for ingest.
 *
 * @return array
 *   A list of component field types that can be sources for ingestion to a
 *   datastream.
 */
function islandora_webform_ingest_get_component_types() {

  $eligible_component_types = array(
    'date',
    'email',
    'file',
    'hidden',
    'number',
    'select',
    'textarea',
    'textfield',
    'time',
  );

  return array_intersect($eligible_component_types, array_keys(webform_components()));

}

/**
 * Function for handling ajax request.
 *
 * @param array $form
 *   The whole drupal form
 * @param array $form_state
 *   the form_state
 *
 * @return array
 *   The portion of the form being reloaded via ajax
 */
function iwi_ds_field_options_ajax($form, &$form_state) {
  // Return the fields dropdown list including the wrapper.
  return $form['ingest']['fields_wrapper'];
}


/**
 * Get a list of ingestable fields from a given datastream edit form.
 *
 * @param array $association
 *   An xml form associated with the datastream
 * @param array $mimefilter
 *   An array of mimetypes that we are going to filter by; if empty, we permit
 *   all mimetypes.
 *
 * @return array
 *   An array to be used as the fields option list in a form
 */
function iwi_ds_field_options($association, $mimefilter = array()) {

  module_load_include('inc', 'islandora_webform_ingest', 'includes/utilities');

  $form_state = array();
  $form = array();

  // Get the render array for the datastream's edit form.
  $form = xml_form_builder_get_form($form, $form_state, $association['form_name']);

  $field_options = array();

  if ($form) {

    // Parse the form into an array with field path and mimetype for each
    // eligible field.
    $field_paths = iwi_form_field_paths($form);

    // Build the field options list, filtering out unsupported mimetypes.
    foreach ($field_paths as $field) {
      if (!empty($mimefilter)) {
        if (count(array_intersect($field['mimes'], (array) $mimefilter))) {
          $field_options[$field['field path']] = $field['field path'] . ' (' . implode(', ', $field['mimes']) . ')';
        }
      }
      else {
        $field_options[$field['field path']] = $field['field path'] . ' (' . implode(', ', $field['mimes']) . ')';
      }
    }
  }
  return $field_options;


}

/**
 * Implements hook_iw_results_object_submissions_page_element_alter().
 *
 * Here we are adding ingest links for individual submissions.
 * TODO If bulk ingest is implemented, we would add that here as well
 */
function islandora_webform_ingest_iw_results_object_submissions_page_element_alter(&$element) {

  if (user_access('ingest islandora webform submissions')) {

    // Failed to get ctools modal popup form to work.
    // TODO: Set $model to TRUE if we want to try again.
    $modal = FALSE;

    drupal_add_css(drupal_get_path('module', 'islandora_webform_ingest') . '/css/islandora_webform_ingest.css');

    if ($modal) {
      ctools_include('modal');
      ctools_modal_add_js();
    }
    else {
      $destination = drupal_get_destination();
    }


    $bulk = user_access('bulk ingest islandora webform submissions');
    // TODO FUTURE: Remove the next line to enable bulk ingestion.
    $bulk = FALSE;

    module_load_include('inc', 'islandora_webform', 'includes/utilities');
    module_load_include('inc', 'islandora_webform_ingest', 'includes/utilities');

    $submission_ids = array_keys($element['#submissions']);
    $pid = $element['#object']->id;

    foreach ($element['table']['#rows'] as $rownum => &$row) {
      $sid = $submission_ids[$rownum];
      $link = '';
      if (iwi_ingest_access($sid)) {

        // Check to see if this has previously been ingested, if so,
        // change link text.
        $ingested = iwi_get_ingestion_info($sid);
        $link_text = t('Ingest');
        $link_options = array(
          'attributes' => array(
            'title' => t('Review and ingest this submission'),
            'class' => array(
              'islandora_webform_ingest',
            ),
          ),
        );
        if ($modal) {
          $link_options['attributes']['class'][] = 'ctools-use-modal';
          $link_url = 'islandora_webform_submission/nojs/ingest/' . $sid;
        }
        else {
          $link_options['query'] = $destination;
          $link_url = 'islandora_webform_submission/ingest/' . $sid;
        }
        if ($ingested) {
          $link_text = t('Re-Ingest');
          $link_options['attributes']['class'][] = 'ingested';
          $link_options['attributes']['title'] = t('This submission has previously been ingested. Click to review and re-ingest this submission');
        }

        // TODO: Set up a model ingestion preview/confirm popup
        // and configure this link to fire it.
        $link = l($link_text, $link_url, $link_options);
      }
      $row[] = $link;
      if ($bulk) {
        // TODO FUTURE: Implement bulk ingestion - this is just for UI demo.
        array_unshift($row, '<input type="checkbox">');
      }
    }
    foreach ($element['table']['#header'] as $hkey => &$header) {
      if (isset($header['data']) && isset($header['colspan']) && $header['data'] == 'Operations') {
        $header['colspan'] += 1;
      }
    }
    if ($bulk) {
      // TODO FUTURE: Implement bulk ingestion - this is just for UI demo.
      array_unshift($element['table']['#header'], '<input type="checkbox">');
      $element['table']['#suffix'] = '<input type="submit" value="Bulk ingest">';
    }

    $element['table']['#operation_total'] += 1;
  }
}

/**
 * Ajax callback to render the ingest form.
 *
 * @param bool $js
 *   True if ajax enabled
 * @param int $sid
 *   The webform submission id
 *
 * @return array|mixed
 *   If js, return form array; otherwise, execute ajax render (no return)
 */
function iwi_preview_ingest_submission_form_callback($js, $sid) {
  if ($js) {
    ctools_include('ajax');
    ctools_include('modal');
    $form_state = array(
      'ajax' => TRUE,
      'title' => t('Ingest Webform Submission'),
    );
    $form_state['build_info']['args'] = array($sid);
    $output = ctools_modal_form_wrapper('iwi_preview_ingest_submission_form', $form_state);
    if (!empty($form_state['executed'])) {

      // Add the responder javascript, required by ctools.
      ctools_add_js('ajax-responder');

      // Create ajax command array, dismiss the modal window.
      $output = array();
      $output[] = ctools_modal_command_dismiss();
      $output[] = ctools_ajax_command_reload();
    }
    ajax_render($output);
    exit;
  }
  else {
    module_load_include('inc', 'islandora_webform_ingest', 'includes/ingest_page');
    return drupal_get_form('iwi_preview_ingest_submission_form', $sid);
  }
}

/**
 * Implements hook_block_info().
 *
 * Define a block for each distinct relation term defined in webform
 * ingest configurations.
 */
function islandora_webform_ingest_block_info() {
  $webforms = db_select('islandora_webform_ingest_webforms', 'iw')
    ->distinct()
    ->fields('iw', array('relation'))
    ->execute()->fetchAll();
  $items = array();

  foreach ($webforms as $webform) {
    $items[$webform->relation] = array(
      'info' => 'Objects with ' . $webform->relation . ' relation',
      'cache' => DRUPAL_NO_CACHE,
      'visibility' => BLOCK_VISIBILITY_LISTED,
      'pages' => 'islandora/object/*',
    );
  }

  return $items;
}

/**
 * Implements hook_block_configure().
 */
function islandora_webform_ingest_block_configure($delta = '') {
  $form = array();
  $form['view_mode'] = array(
    '#type' => 'select',
    '#title' => t('View mode'),
    '#default_value' => variable_get('islandora_webform_ingest_block_view_mode_' . $delta, 'grid'),
    '#description' => t('Select the way objects should appear in this block.'),
    '#options' => array(
      'grid' => 'Grid',
      'list' => 'List',
      'links' => 'Links',
    ),
  );
  $form['page_count'] = array(
    '#type' => 'textfield',
    '#title' => t('Page count'),
    '#default_value' => variable_get('islandora_webform_ingest_block_page_count_' . $delta, '10'),
    '#description' => t('How many objects may appear in the related objects block at one time? A pager will be added if the count exceeds this number.'),
  );
  $form['sort_by'] = array(
    '#type' => 'select',
    '#title' => t('Sort by'),
    '#default_value' => variable_get('islandora_webform_ingest_block_sort_by_' . $delta, '?date_modified'),
    '#description' => t('How should the objects be sorted?'),
    '#options' => array(
      '?date_modified' => 'Most recent',
      '?title' => 'Title',
      '?object' => 'Object PID',
    ),
  );
  return $form;
}

/**
 * Implements hook_block_save().
 */
function islandora_webform_ingest_block_save($delta = '', $edit = array()) {
  if (isset($edit['view_mode'])) {
    variable_set('islandora_webform_ingest_block_view_mode_' . $delta, $edit['view_mode']);
  }
  if (isset($edit['page_count'])) {
    variable_set('islandora_webform_ingest_block_page_count_' . $delta, $edit['page_count']);
  }
  if (isset($edit['sort_by'])) {
    variable_set('islandora_webform_ingest_block_sort_by_' . $delta, $edit['sort_by']);
  }
}


/**
 * Implements hook_block_view().
 *
 * Displays objects related by the rels-ext $relation to the currently
 * displayed object, using view mode configured in the block settings.
 *
 * We are calling $delta "$relation" - they are the same thing in this case.
 */
function islandora_webform_ingest_block_view($relation = '') {
  $object = islandora_object_load(arg(2));
  $block = array(
    'subject' => $relation,
  );
  if ($object) {
    $view_mode = variable_get('islandora_webform_ingest_block_view_mode_' . $relation, 'grid');
    $page_number = (empty($_GET['page'])) ? 0 : $_GET['page'];
    $page_size = (empty($_GET['pagesize'])) ? variable_get('islandora_webform_ingest_block_page_count_' . $relation, '10') : $_GET['pagesize'];

    // Get objects.
    list($results_count, $results) = islandora_webform_ingest_get_related_objects($object, $relation, $page_number, $page_size, $type = 'view');

    // Theme the objects using the selected view mode.
    if ($results_count) {

      // Initialize pager.
      pager_default_initialize($results_count, $page_size);
      $collection_pager = theme('pager', array('quantity' => 10));

      switch ($view_mode) {
        case 'grid':
          $collection_content = theme('islandora_basic_collection_grid', array(
              'islandora_object' => $object,
              'collection_results' => $results,
            )
          );
          break;

        case 'list':
          $collection_content = theme('islandora_basic_collection', array(
              'islandora_object' => $object,
              'collection_results' => $results,
            )
          );
          break;

        default:
          // Default is to show a list of links.
          $links = array();
          foreach ($results as $result) {
            if (!empty($result['title']['value']) && !empty($result['object']['value'])) {
              $links[] = l($result['title']['value'], 'islandora/object/' . $result['object']['value']);
            }
          }
          $collection_content = theme('item_list', array('items' => $links));
          break;
      }

      $block['content'] = $collection_content . $collection_pager;
    }
  }

  return $block;
}

/**
 * Implements hook_islandora_basic_collection_query_param_alter().
 *
 * Substitute relation predicate for the collection predicates.
 */
function islandora_webform_ingest_islandora_basic_collection_query_param_alter(&$query_filters, &$query_statements, &$params, &$query_optionals) {
  if (!empty($params['relation'])) {
    foreach ($query_filters as &$query_filter) {
      if (strpos($query_filter, 'sameTerm(?collection_predicate') !== FALSE && strpos($query_filter, "<fedora-rels-ext:" . $params['relation'] . ">)") === FALSE) {
        $query_filter = "sameTerm(?collection_predicate, <fedora-rels-ext:" . $params['relation'] . ">)";
      }
      break;
    }

  }
}


/**
 * Implements hook_islandora_basic_collection_query_alter().
 *
 * We need to be able to change order-by to descending if ordering by date.
 * islandora_basic_collection_get_query_info() sorts ascending and this can't
 * be modified by hook_islandora_basic_collection_query_param_alter, so we
 * need to override that after the query is built.
 */
function islandora_webform_ingest_islandora_basic_collection_query_alter(&$query_array) {

  if (!empty($query_array['relation'])) {

    $order_by = variable_get('islandora_webform_ingest_block_sort_by_' . $query_array['relation'], '?date_modified');
    $query_array['order_by'] = $order_by;
    if ($order_by == '?date_modified') {
      $order_by_expression = 'ORDER BY DESC(' . $order_by . ')';
    }
    else {
      $order_by_expression = 'ORDER BY ' . $order_by;
    }
    $order_by_pattern = '/ORDER BY \?\S*/';
    $query_array['query'] = preg_replace($order_by_pattern, $order_by_expression, $query_array['query']);
  }
}

/**
 * Get objects associated with this object.
 *
 * This is copied from islandora_basic_collection_get_member_objects(). We make
 * one small change - we add a $relation parameter to the $parameters array
 * prior to calling islandora_basic_collection_get_query_info(). This signals
 * to our hook_islandora_basic_collection_query_param_alter() to remove the
 * collection member filters and replace them with our relation filter.
 *
 * @param AbstractObject $object
 *   The object whose related objects will be fetched.
 * @param string $relation
 *   The rels-ext relation string
 * @param int $page_number
 *   The page number in the query for related objects.
 * @param int $page_size
 *   The number of results per page page from the query for related objects.
 * @param string $type
 *   Either 'view' or 'manage', its meant to represent how the objects will be
 *   used.
 * @param string $cmodel
 *   The content model in which to explicitly select.
 *
 * @return array|bool
 *   An array containing two values:
 *   - An integer representing the total number of tuples which can be
 *     selected with the given parameters.
 *   - The tuples in the slice according to $page_number and $page_size.
 *   or boolean FALSE if the query fails.
 */
function islandora_webform_ingest_get_related_objects(AbstractObject $object, $relation, $page_number = 0, $page_size = 20, $type = 'view', $cmodel = NULL) {
  $params = array(
    'object' => $object,
    'page_number' => $page_number,
    'page_size' => $page_size,
    'relation' => $relation,
  );

  if (isset($cmodel)) {
    $params['model'] = "<info:fedora/$cmodel>";
  }
  // Utilize the basic collection query function, then modify it for our
  // purpose.
  $query_array = islandora_basic_collection_get_query_info($params, $type);
  try {
    $count = variable_get('islandora_basic_collection_disable_count_object', FALSE) ? 0 : $object->repository->ri->countQuery($query_array['query'], $query_array['type']);
    $is_itql = strcasecmp('itql', $query_array['type']) === 0;

    if ($is_itql && ($page_number > 0 || $page_size >= 0)) {
      // Strip the final semi-colon(s) of any itql query, where they exist.
      $query = trim($query_array['query']);
      while (strpos($query, -1) == ';') {
        $query = substr($query, 0, -1);
      }
      $query_array['query'] = $query;
    }

    if ($page_number > 0 && $page_size > 0) {
      // Add in the offset somehow.
      $offset = $page_number * $page_size;
      $query_array['query'] .= " offset $offset";
    }
    if ($page_size >= 0) {
      // Add in the limit somehow.
      $query_array['query'] .= " limit $page_size";
    }

    if ($is_itql) {
      // Add in the final semi-colon.
      $query_array['query'] .= ';';
    }

    $results = $object->repository->ri->query($query_array['query'], $query_array['type']);
  }
  catch (Exception $e) {
    $variables = array(
      '@message' => $e->getMessage(),
      '@stack' => $e->getTraceAsString(),
    );
    watchdog('islandora_webform_ingest',
      'Islandora webform ingest related objects failed to retrieve associated objects.<br/>Error:<br/>@message<br/>Stack: <br/>@stack',
      $variables,
      WATCHDOG_ERROR);
    return FALSE;
  }
  return array($count, $results);
}
